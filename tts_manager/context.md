### **Задача: Модуль tts_manager.py (v2, гибридный с менеджером соединений)**

Этот документ описывает финальную, утвержденную спецификацию для модуля TTSManager. Версия 2 вводит отдельный класс для управления WebSocket-соединениями, чтобы гарантировать минимальную задержку при работе с потоковыми ответами от LLM.

#### **1. Контекст и цель модуля (CONTEXT)**

TTSManager является **"голосом"** системы. Его единственная задача — быть высокопроизводительным и отказоустойчивым клиентом для API ElevenLabs. Он предоставляет Orchestrator-у унифицированный интерфейс для генерации речи, автоматически выбирая самый быстрый метод (HTTP Streaming или WebSocket) в зависимости от задачи.

* **Потребители:** Orchestrator является единственным потребителем.  
* **Жизненный цикл:** TTSManager и его зависимости не являются **Singleton**, они создаются оркестратором на каждый новый звонок. Оркестратор создает изолированную цепочку на каждый звонок, включая классы работы с соединениями

#### **2. Архитектура и компоненты**

Модуль будет состоять из двух четко разделенных по ответственности классов.

**2.1. WebSocketConnectionManager**

**2.1. tts_manager/connection_manager.py -> Класс WebSocketConnectionManager**

Назначение: Этот класс — менеджер жизненного цикла одного WebSocket-соединения. Его задача — установить соединение для одного конкретного диалога, поддерживать его в "горячем" состоянии с помощью keep-alive сообщений и корректно закрыть его по завершении.

Архитектурное решение (ВАЖНО): Этот класс не является Singleton. Для каждого одновременного диалога, которому требуется стриминг ответа от LLM, TTSManager будет создавать новый, изолированный экземпляр WebSocketConnectionManager. Это полностью решает проблему "узкого места" и позволяет системе обрабатывать множество параллельных LLM-ответов.

Публичные методы:

_*init*_(self, config):

Назначение: Конструктор. Принимает конфигурацию (API-ключ, voice_id, model_id и т.д.), необходимую для установки соединения.

Логика: Сохраняет конфиг, инициализирует внутренние переменные (self.websocket = None, self.keep_alive_task = None).

async connect(self) -> WebSocketClientProtocol:

Назначение: Основной метод для установки соединения. Вызывается оркестартором и передается в TTSManager.

Логика:

Формирует URL для WebSocket-соединения на основе конфига.

Устанавливает соединение с помощью библиотеки websockets.

Сохраняет активное соединение в self.websocket.

Запускает в фоне приватную корутину self._keep_alive_task(), которая будет поддерживать соединение.

Возвращает живой и готовый к использованию объект соединения.

`async close(self)`:

Назначение: Метод для корректного завершения работы. Вызывается TTSManager-ом, когда LLM-стрим для данного диалога больше не нужен.

Логика:

Отменяет фоновую задачу self.keep_alive_task.

Проверяет, что self.websocket существует и не закрыт, после чего отправляет финальное пустое сообщение {"text": ""} для flush'а буфера на стороне ElevenLabs.

Закрывает WebSocket-соединение.

Приватные методы:

async _keep_alive_task(self):

Назначение: Фоновая задача, которая предотвращает разрыв соединения по таймауту неактивности.

Логика:

Входит в бесконечный цикл while True.

Ожидает 15 секунд (await asyncio.sleep(15)).

Отправляет в сокет "пустое" сообщение ({"text": " "}), которое сбрасывает таймер неактивности на сервере, но не генерирует аудио.

Обрабатывает исключения на случай, если соединение оборвалось, и корректно завершает задачу.

**2.2. tts_manager/manager.py -> Класс TTSManager**

* **Назначение:** Является "фасадом" для Orchestrator. Реализует гибридную логику, выбирая оптимальный способ генерации речи.  
* **Зависимости:** Принимает WebSocketConnectionManager в качестве зависимости.  
* **Публичные методы:**  
  * __init__(self, config, connection_manager): Конструктор.  
  * async stream_static_text(self, text: str): **Метод для сценариев.** Использует **HTTP Streaming API**.  
  * async start_llm_stream(self): **Метод для LLM.** Использует **WebSocket**, получая готовое соединение от connection_manager. Может выкинуть исключение TTSConnectionError, если соединение не удалось, оркестратор обязан его обработать и попробовать подключиться еще раз

#### **3. Детальная спецификация TTSManager (v2)**

**3.1. async stream_static_text(self, text: str)**

* **Логика:** Формирует и отправляет POST запрос на .../stream с параметром optimize_streaming_latency=4. Асинхронно возвращает аудио-чанки.

**3.2. async start_llm_stream(self)**

* **Логика:**  
  1. **Получает "горячее" соединение:** websocket = await self.connection_manager.get_connection().  
  2. Создает две asyncio.Queue: text_input_queue и audio_output_queue.  
  3. Запускает в фоне две задачи: _ws_send_task(websocket, text_input_queue) и _ws_receive_task(websocket, audio_output_queue). **Важно:** задачи теперь принимают готовый объект websocket как аргумент.  
  4. Возвращает (text_input_queue, audio_output_queue).  
* **Логика _ws_send_task и _ws_receive_task:** *Остается прежней*, но теперь они работают с уже установленным соединением, которое им передали. Задача инициализации соединения из них уходит.

#### **4. Стратегии минимизации задержки**

1. **Гибридный API:** Orchestrator вызывает stream_static_text для всех заранее известных фраз (числа, реплики из dialogue_map) и start_llm_stream для ответов, генерируемых LLMManager.  
2. **Устранение задержки Handshake:** WebSocketConnectionManager устанавливает соединение при старте приложения и поддерживает его с помощью keep-alive сообщений. TTSManager всегда получает уже готовое соединение, экономя 100-300 мс на каждом LLM-ответе.  
3. **Оптимальные параметры:** Всегда используются параметры optimize_streaming_latency=4 для HTTP и auto_mode=true для WebSocket.  
4. **Быстрые модели:** В конфигурации по умолчанию используется eleven_turbo_v2 или аналогичная быстрая модель.