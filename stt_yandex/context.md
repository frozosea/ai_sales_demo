---
#### **1. Контекст и цель модуля (CONTEXT) - (ПЕРЕРАБОТАННАЯ ВЕРСИЯ)**

**1.1. Роль в системе:**
Модуль `stt_yandex.py` является **"ушами"** системы. Его единственная задача — быть высокопроизводительным и отказоустойчивым клиентом для Yandex SpeechKit v3 gRPC API. Он инкапсулирует всю сложность взаимодействия с этим внешним сервисом.

**1.2. Потребитель (Consumer):**
Единственным потребителем (клиентом) этого модуля является **`Orchestrator`**. Никакой другой компонент системы не должен взаимодействовать с `stt_yandex.py` напрямую.

**1.3. Жизненный цикл (Lifecycle):**
Для каждого нового диалога (`call session`) `Orchestrator` создает **новый, одноразовый экземпляр** класса `YandexSTTStreamer`. После завершения распознавания речи в рамках диалога (или при обрыве звонка) `Orchestrator` вызывает метод `stop_recognition()`, и экземпляр уничтожается.
* **Примечание для демо:** Такая модель (один экземпляр на звонок) является упрощением. В продуктивной среде для оптимизации может быть использован паттерн "Фабрика", который переиспользует gRPC-каналы между звонками.

**1.4. Поток данных (Data Flow):**
Взаимодействие между Оркестратором и `YandexSTTStreamer` происходит через две асинхронные очереди (`asyncio.Queue`) для обеспечения полной асинхронности и противодавления.
1.  **`Orchestrator`** создает очередь для отправки аудио `audio_chunk_queue` (с ограниченным `maxsize`).
2.  **`Orchestrator`** создает экземпляр `YandexSTTStreamer`.
3.  **`Orchestrator`** вызывает `stt_streamer.start_recognition(audio_chunk_queue)` и немедленно получает взамен `response_queue`.
4.  **`Orchestrator`** в своей основной логике начинает асинхронно писать (`await .put()`) байтовые чанки аудио в `audio_chunk_queue`.
5.  **Параллельно**, **`Orchestrator`** в другой асинхронной задаче начинает асинхронно читать (`await .get()`) результаты из `response_queue`.
6.  `YandexSTTStreamer` внутри себя читает из `audio_chunk_queue` и пишет результаты в `response_queue`.
7.  Когда **`Orchestrator`** решает прекратить распознавание, он вызывает `await stt_streamer.stop_recognition()`.

Этот паттерн полностью отвязывает логику Оркестратора от внутренней реализации STT-клиента.

**1.5. Метрики работы класса**

**Idle Period:** 30 seconds

## Performance Impact Summary

| Metric | Before | After | Change | Status |
|--------|---------|--------|---------|---------|
| Handshake (avg) | 383.2 ms | 0.3 ms | -99.9% | ✅ Good |
| TTFP (avg) | 366.2 ms | 192.0 ms | -47.6% | ✅ Good |
| TTFF (avg) | 1102.1 ms | 719.8 ms | -34.7% | ✅ Good |

## Detailed Metrics

### Before Idle Period

| Metric | Average | p50 | p95 |
|--------|---------|-----|-----|
| Handshake | 383.2 ms | 0.4 ms | 1914.7 ms |
| TTFP | 366.2 ms | 287.1 ms | 612.3 ms |
| TTFF | 1102.1 ms | 1208.0 ms | 1517.5 ms |

### After Idle Period

| Metric | Average | p50 | p95 |
|--------|---------|-----|-----|
| Handshake | 0.3 ms | 0.3 ms | 0.5 ms |
| TTFP | 192.0 ms | 186.8 ms | 213.1 ms |
| TTFF | 719.8 ms | 698.9 ms | 796.9 ms |

## Analysis

1. **Handshake Impact:**
   - Average degradation: -99.9%
   - Status: ✅ Good
   - No significant impact on connection setup time.

2. **First Partial Recognition (TTFP):**
   - Average degradation: -47.6%
   - Status: ✅ Good
   - Model maintains good responsiveness after idle period.

3. **First Final Recognition (TTFF):**
   - Average degradation: -34.7%
   - Status: ✅ Good
   - Final recognition timing remains stable.


### **Задача для LLM: Модуль `stt_yandex.py` (Финальная, оптимизированная версия)**

**1. Контекст и цель модуля (CONTEXT):**
Модуль является высокопроизводительным и отказоустойчивым клиентом для Yandex SpeechKit v3 gRPC API. Он предназначен для работы в асинхронной среде `asyncio` и является критически важным компонентом в пайплайне распознавания речи. Его главная задача — принимать аудиопоток, эффективно управляя сетевым соединением и ресурсами, и предоставлять `Orchestrator`-у поток типизированных, удобных для анализа `partial` и `final` результатов распознавания.

**2. Основные требования к реализации (REQUIREMENTS):**

**2.0. Структуры данных:**

  * **`STTResponse`:** Создать `dataclass` с опцией `slots=True` для максимальной производительности и уменьшения потребления памяти.
    ```python
    from dataclasses import dataclass

    @dataclass(slots=True)
    class STTResponse:
        text: str
        is_final: bool
        stability_level: float
        utterance_index: int
    ```
  * **`STTConfig`:** Создать `dataclass` для инкапсуляции всех настроек сессии gRPC, включая `model`, `sample_rate_hertz` и `eou_sensitivity`.

* Модуль **импортирует** `STTResponse`, `STTConfig` и `STTConnectionError` из общего модуля `domain.py`.

**2.1. Архитектура класса `STTConnectionPool`:**

* Класс `STTConnectionPool` отвечает за управление пулом соединений для Yandex SpeechKit STT. Он обеспечивает создание, прогрев и повторное использование gRPC-соединений для минимизации задержек при установке соединения.

* **Конструктор `__init__`:**
  * Принимает параметры конфигурации `STTConfig`, IAM токен и идентификатор папки.
  * Инициализирует пул соединений с заданным максимальным количеством соединений и временем простоя.
  * Запускает фоновую задачу для очистки неактивных соединений.

* **Метод `_create_connection()`:**
  * Создает новое gRPC-соединение с использованием безопасного канала и возвращает его идентификатор и объект соединения `WarmConnection`.

* **Метод `_warm_up_connection(connection_id, conn)`:**
  * Прогревает соединение, отправляя тестовый аудиочанк (200 мс тишины) для подготовки модели к обработке реальных данных.

* **Метод `acquire()`:**
  * Асинхронно получает прогретое соединение из пула.
  * Если доступных соединений нет, создает новое, если пул не заполнен, или ожидает освобождения существующего.

* **Метод `release(connection_id)`:**
  * Освобождает соединение, возвращая его в пул для повторного использования.

* **Метод `_cleanup_idle_connections()`:**
  * Периодически очищает неактивные соединения, которые не использовались в течение заданного времени простоя.

* **Метод `close()`:**
  * Закрывает все соединения в пуле и завершает фоновую задачу очистки.

* **Класс `WarmConnection`:**
  * Представляет собой объект соединения, содержащий канал, заглушку и метаданные о состоянии соединения (например, было ли отправлено конфигурационное сообщение, время последнего использования, флаг использования).

* **Логирование:**
  * Все ключевые операции (создание, прогрев, освобождение, очистка) логируются с использованием JSON-формата для упрощения анализа и отладки.

* **Обработка ошибок:**
  * Все асинхронные операции обернуты в `try...except` для обработки и логирования ошибок, связанных с gRPC и асинхронными задачами.


**2.2. Архитектура класса `ConnectionManager`:**

* Класс `ConnectionManager` управляет пулом соединений для Yandex SpeechKit STT, обеспечивая автоматическое прогревание соединений и поддержание их в активном состоянии. Он взаимодействует с классом `STTConnectionPool` для управления жизненным циклом соединений.

* **Конструктор `__init__`:**
  * Принимает параметры конфигурации `STTConfig`, IAM токен, идентификатор папки и опциональную конфигурацию менеджера соединений `ConnectionManagerConfig`.
  * Создает экземпляр `STTConnectionPool` для управления пулом соединений.
  * Запускает фоновую задачу для периодического прогревания соединений.

* **Метод `initialize(...)`:**
  * Инициализирует синглтон-экземпляр `ConnectionManager`.
  * Если экземпляр уже существует, возвращает его.

* **Метод `get_instance()`:**
  * Возвращает синглтон-экземпляр `ConnectionManager`.
  * Если экземпляр не был инициализирован, выбрасывает исключение.

* **Метод `_warmup_loop()`:**
  * Периодически прогревает все неактивные соединения в пуле.
  * Использует метод `_warm_up_connection` из `STTConnectionPool` для прогрева каждого соединения.

* **Метод `acquire_connection()`:**
  * Асинхронно получает прогретое соединение из пула через `STTConnectionPool.acquire()`.

* **Метод `release_connection(connection_id)`:**
  * Освобождает соединение, возвращая его в пул через `STTConnectionPool.release()`.

* **Метод `close()`:**
  * Закрывает менеджер соединений и все соединения в пуле.
  * Завершает фоновую задачу прогрева.

* **Иерархическое взаимодействие с `STTConnectionPool`:**
  * `ConnectionManager` создает и управляет экземпляром `STTConnectionPool`.
  * `STTConnectionPool` отвечает за создание, прогрев и очистку соединений.
  * `ConnectionManager` использует методы `STTConnectionPool` для получения и освобождения соединений, а также для их прогрева.

* **Логирование:**
  * Все ключевые операции (инициализация, прогрев, получение и освобождение соединений) логируются для упрощения отладки и мониторинга.

* **Обработка ошибок:**
  * Все асинхронные операции обернуты в `try...except` для обработки и логирования ошибок, связанных с gRPC и асинхронными задачами.

**2.3. Архитектура класса `YandexSTTStreamer`:**

* Класс `YandexSTTStreamer` управляет жизненным циклом gRPC-соединения и фоновых задач для Yandex SpeechKit STT. Он использует `ConnectionManager` для управления соединениями, который в фоне автоматически прогревает соединения и модель. Это позволяет всегда иметь открытое соединение на каждый вызов.

* **Конструктор `__init__`:**
  * Принимает `STTConfig`, IAM токен и идентификатор папки.
  * Инициализирует `ConnectionManager`, который создает прогретое соединение на основе класса по работе с пулом соединений из `stt_connection_pool.py`.
  * Генерирует уникальный `trace_id` для каждого экземпляра для отслеживания логов.

* **Основной метод `start_recognition(...)`:**
  * Должен быть асинхронным.
  * Принимает на вход `audio_chunk_queue: asyncio.Queue`. **Важно:** Оркестратор должен создавать эту очередь с параметром `maxsize` (например, `maxsize=50`) для реализации механизма противодавления.
  * Получает соединение из `await ConnectionManager.get_instance().acquire_connection()`.
  * Создает и возвращает `response_queue: asyncio.Queue`, из которой Оркестратор будет асинхронно читать готовые объекты `STTResponse`.
  * Запускает две приватные фоновые задачи (`asyncio.Task`) для отправки и получения данных.
  * Сохраняет ссылки на эти задачи, чтобы иметь возможность их остановить.

* **Метод `stop_recognition()`:**
  * Должен быть асинхронным.
  * Корректно отменяет (`task.cancel()`) и ожидает завершения фоновых задач.
  * Освобождает соединение, возвращая его в пул через `ConnectionManager.release_connection()`.

* **Логика фоновых задач:**

  * **Приватная корутина `_send_requests(grpc_stream, audio_chunk_queue)`:**
    1. Формирует и отправляет **первое** сообщение с `session_options` на основе `self.config`.
    2. Входит в цикл `while True`.
    3. Асинхронно ожидает (`await audio_chunk_queue.get()`) и получает аудио-чанк из очереди.
    4. Отправляет чанк в gRPC-стрим, обернув его в `StreamingRequest(chunk=...)`.
    5. Обрабатывает маркер конца потока (например, `None`) для штатного завершения отправки.

  * **Приватная корутина `_receive_responses(grpc_stream, response_queue)`:**
    1. Инициализирует внутренний счетчик `current_utterance_index = 0`.
    2. Входит в цикл `async for response in grpc_stream`.
    3. При получении сообщения `final` **инкрементирует** `current_utterance_index`.
    4. Вызывает приватный метод `_parse_response(response, current_utterance_index)` для преобразования Protobuf-сообщения в `STTResponse`.
    5. Если парсинг успешен, кладет результат в `response_queue` (`await response_queue.put(...)`).

* **Возвращаемые значения:** В `response_queue` помещаются **кортежи (tuples)** формата `(result, error)`.
  * **Успех:** `(STTResponse, None)`.
  * **Ошибка:** `(None, STTConnectionError)`.

* **Парсинг:** Логика парсинга должна корректно отслеживать `utterance_index` на основе `final` сообщений.

* **Противодавление (Backpressure):** `audio_chunk_queue` должна создаваться Оркестратором с ограниченным `maxsize`.

* **Логирование:**
  * Все ключевые операции (инициализация, отправка и получение данных, ошибки) логируются с использованием JSON-формата для упрощения анализа и отладки.

* **Обработка ошибок:**
  * Все асинхронные операции обернуты в `try...except grpc.aio.AioRpcError` для обработки и логирования ошибок, связанных с gRPC.

**2.4. Логика парсинга `_parse_response`:**

  * Метод должен принимать `response: StreamingResponse` и `current_utterance_index: int`.
  * Он должен проверять тип события (`partial` или `final`).
  * Он должен корректно извлекать текст и `confidence` из `response.partial.alternatives[0]` или `response.final.alternatives[0]`.
  * Он должен использовать переданный `current_utterance_index` для заполнения соответствующего поля в `STTResponse`, **игнорируя** `response.audio_cursors.final_index` для `partial` результатов.

**2.5. Обработка ошибок:**

  * Обе фоновые корутины должны быть обернуты в `try...except grpc.aio.AioRpcError`.
  * При возникновении ошибки gRPC, она должна быть залогирована, а в `response_queue` должно быть помещено специальное сообщение об ошибке или выброшено исключение, которое будет обработано Оркестратором.

**3. Зависимости (DEPENDENCIES):**

  * **Внешние:** `grpcio`, `yandex.cloud.api`, `asyncio`, `dataclasses`.
  * **Внутренние:** Отсутствуют.

**4. План тестирования (TESTING PLAN):**

  * **Интеграционный тест:** Проверить полный цикл: запуск `start_recognition`, отправка аудио-чанков в `audio_chunk_queue`, получение `STTResponse` из `response_queue`, вызов `stop_recognition`.
  * **Тест на противодавление (Backpressure):** Создать `audio_chunk_queue` с маленьким `maxsize`, быстро заполнить ее и убедиться, что вызывающая сторона блокируется, а не падает с ошибкой памяти.
  * **Тест на отмену:** Вызвать `stop_recognition` в середине процесса и убедиться, что фоновые задачи корректно отменяются и gRPC-соединение закрывается.
  
### Быстрый запуск (после реализации трёх задач)

#### 0) Установить зависимости
python -m pip install -U grpcio grpcio-tools requests python-dotenv PyYAML

#### 1) Сгенерировать stubs (один раз, интернет нужен)
python scripts/fetch_speechkit_protos.py --dest third_party/speechkit_stt_v3
python scripts/gen_speechkit_stubs.py --src third_party/speechkit_stt_v3 --out third_party/speechkit_stt_v3

#### 2) Проверить креды
cp .env.example .env
#### ... вписать YC_IAM_TOKEN, YC_FOLDER_ID ...
python scripts/check_yc_creds.py

#### 3) Прогнать песочницу клиента (без аудио)
python -m stt_yandex.stt_yandex  # if __main__ внутри файла

#### 4) Ручной e2e-тест со стримингом WAV
python stt_yandex/test/manual_test_stt.py --wav test_data/example.wav --chunk-ms 20 --repeats 3 --report-dir reports --config configs/stt_config.yml
