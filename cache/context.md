### **Задача: Модуль** cache.py **(Финальная спецификация, гибридная модель)**

Этот документ описывает финальную, утвержденную спецификацию для модуля cache.py, адаптированную для поддержки гибридной генерации аудио и совместимую с другими компонентами системы, включая LLMManager.

#### **1. Контекст и цель модуля (CONTEXT)**

Этот модуль является **высокопроизводительным хранилищем "ключ-значение"** и критически важным компонентом для снижения задержек в системе. Его роль строго разделена на три независимых сценария использования, где кэширование не нарушает логику диалога и приносит максимальную пользу. Модуль инкапсулирует всю логику взаимодействия с Redis.

**Архитектурное решение:** Модуль хранит **три типа данных**:

1. **Статические аудио-фрагменты (Static Audio Fragments):** Это **основная** функция модуля. Здесь хранятся байтовые чанки для всех предзаписанных диктором частей фраз:  
   * Полностью независимые реплики ("Здравствуйте!", "Минуточку...").  
   * "Строительные блоки" для динамических ответов ("Ваша стоимость составляет...", "...рублей").  
   * Слова-филлеры и междометия для создания эффекта живой речи ("Так-с...", "Ага...").  
2. **Кэш результатов TTS-синтеза (TTS Cache):** Для минимизации обращений к внешнему TTS-сервису, модуль кэширует результаты синтеза динамических данных (чисел, дат, имен). Ключом является сам текст (например, tts:12500), значением — байтовый аудио-поток.  
3. **Кэш оптимизации LLM (LLM Cache):** Эта функция остается без изменений. Модуль хранит текстовые результаты дорогостоящих операций, выполняемых модулем llm, в первую очередь — результаты суммаризации диалогов для управления контекстом.

#### **2. Основные требования к реализации (REQUIREMENTS)**

**2.1. Архитектура на основе интерфейсов:**

* Создать абстрактный базовый класс AbstractCache в файле domain/interfaces/cache.py.  
* Создать класс RedisCacheManager в файле cache.py, который наследует от AbstractCache и реализует его методы как **Singleton**.

**2.2. Требования к классу** RedisCacheManager**:**

* **Управление соединением:** Класс должен управлять асинхронным пулом соединений (ConnectionPool) с Redis.  
* **Надежность и отказоустойчивость:** **Каждый** метод, взаимодействующий с Redis, должен быть обернут в блок try...except redis.RedisError, логировать ошибку и возвращать "пустое" значение по умолчанию (None или []), позволяя вызывающему коду продолжить работу.  
* **Неблокирующие операции:** Любые синхронные, потенциально долгие операции (чтение WAV-файла с диска) должны выполняться в отдельном потоке через asyncio.to_thread().

#### **2.3. Реализуемые методы (согласно интерфейсу)**

* connect() **/** close()**:**  
  * Асинхронные методы для управления жизненным циклом пула соединений. Не изменяются.  
* load_and_set_audio(key: str, wav_filepath: str, chunk_size_ms: int = 20)**:**  
  * **Назначение:** Вспомогательный метод для оффлайн-скриптов (load_static_audio.py). Используется для "прогрева" кэша — загрузки **статических аудио-фрагментов**.  
  * **Логика:** Использует asyncio.to_thread для неблокирующего чтения и нарезки WAV-файла. Вызывает внутренний метод set_audio_chunks.  
* set_audio_chunks(key: str, audio_chunks: List[bytes])**:**  
  * **Назначение:** Универсальный метод для сохранения **любого** аудио в кэш. Используется как для статических фрагментов (ключ вида static:welcome), так и для результатов TTS-синтеза (ключ вида tts:12500).  
  * **Логика:** Сохраняет список байтовых аудио-чанков в **Redis List**. Операция должна быть атомарной (через pipeline).  
* get_audio_chunks(key: str) -> Optional[List[bytes]]**:**  
  * **Назначение:** Универсальный метод для получения **любого** аудио из кэша по ключу.  
  * **Логика:** Получает **весь** список аудио-чанков из Redis List. В случае отсутствия ключа или ошибки возвращает None.  
* set_text(key: str, text: str, ttl_seconds: int)**:**  
  * **Назначение:** Используется **только** модулем llm.ConversationManager для кэширования **результатов суммаризации**.  
  * **Логика:** Сохраняет текстовое значение в Redis. **Обязательно** устанавливает время жизни ключа (TTL) для автоматического протухания.  
* get_text(key: str) -> Optional[str]**:**  
  * **Назначение:** Используется **только** модулем llm.ConversationManager для получения кэшированных **суммаризаций**.  
  * **Логика:** Получает текстовое значение по ключу. В случае отсутствия ключа или ошибки возвращает None.

#### **3. Потоки данных (Data Flow)**

* **Поток "Гибридного ответа" (управляется** Orchestrator**):**  
  1. Orchestrator формирует "плейлист" для ответа (например, [cache_key:"static:intro", tts_text:"12500", cache_key:"static:currency"]).  
  2. Для каждого элемента плейлиста он обращается к кэшу.  
  3. Для cache_key: вызывает await cache.get_audio_chunks(key).  
  4. Для tts_text: сначала вызывает await cache.get_audio_chunks("tts:12500").  
     * **Если найдено (Cache Hit):** Использует готовые чанки.  
     * **Если не найдено (Cache Miss):** Обращается к TTS-сервису, получает аудио-чанки, **параллельно** отдает их пользователю и запускает фоновую задачу asyncio.create_task(cache.set_audio_chunks("tts:12500", chunks)) для сохранения в кэш.  
* **Поток "Кэширования Суммаризации" (управляется** llm.ConversationManager**):**  
  * Логика остается без изменений. Перед вызовом LLM для сжатия контекста, ConversationManager проверяет наличие готовой суммаризации в кэше по ключу сессии (await cache.get_text(session_id)). В случае успеха, использует текст из кэша, экономя дорогой вызов к LLM.