### **Спецификация: Серверное Окружение (v2, Production-Ready)**

#### **1. Цель и Принципы**

* **Цель:** Обеспечить высокопроизводительное и отказоустойчивое исполнение `Orchestrator` и связанных с ним сервисов.
* **Принципы:**
    1.  **Разделение ответственности:** Каждый компонент делает только одну задачу и делает ее хорошо.
    2.  **Отказоустойчивость по умолчанию:** Система должна изящно деградировать, а не падать. Сбой второстепенного компонента не должен приводить к остановке всей системы.
    3.  **Сквозная трассировка:** Каждый звонок должен быть отслеживаемым от начала до конца через все компоненты системы.

---

#### **2. Архитектура и Технологический Стек**

Используется трехуровневая модель для разделения **Control Plane** (логика) и **Media Plane** (аудио).

| Уровень | Компонент | Технология | Назначение |
| :--- | :--- | :--- | :--- |
| **Gateway** | Reverse Proxy | **Nginx** | Балансировка нагрузки, терминация SSL, проксирование |
| **Application** | Process Manager | **Gunicorn** | Управление рабочими процессами Python |
| | ASGI Server | **Uvicorn** | Асинхронное исполнение кода `Orchestrator` |
| **Media** | Media Server | **Mediasoup** | Обработка RTP-потоков (WebRTC) |

---

#### **3. Компоненты Системы**

##### **3.1. Nginx (Gateway)**

* **Конфигурация:**
    * Настраивается на прием HTTPS и WSS (Secure WebSocket) трафика на стандартных портах (443).
    * Выполняет SSL/TLS терминацию с использованием сертификатов.
    * Настраивается `upstream` блок для балансировки нагрузки (round-robin) на несколько экземпляров Gunicorn/Uvicorn.
    * Содержит `location` блок для корректного проксирования WebSocket (`proxy_http_version 1.1`, `Upgrade`, `Connection "upgrade"`).
    * **(Трассировка)** Генерирует или принимает извне `X-Trace-ID` и пробрасывает его в заголовках (`proxy_set_header`) в Application Server.

##### **3.2. Gunicorn + Uvicorn (Application)**

* **Запуск:** `gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`
* **Gunicorn (Менеджер):**
    * Отвечает за запуск и мониторинг `N` рабочих процессов Uvicorn (`--workers`). Количество `workers` = `(2 * CPU cores) + 1`.
    * Автоматически перезапускает `worker`-ов, которые "умерли" из-за непредвиденной ошибки.
* **Uvicorn (Исполнитель):**
    * Реализует ASGI-интерфейс.
    * Предоставляет **один** WebSocket endpoint: `/api/v1/call`.
    * При получении нового WebSocket-соединения, выполняет следующую логику:
        1.  Извлекает `trace_id` из заголовков запроса.
        2.  Извлекает `call_id` и начальные переменные из первого сообщения клиента.
        3.  Вызывает асинхронную фабрику `create_orchestrator_instance(call_id, trace_id, initial_vars)`.
        4.  Если фабрика отработала успешно, вызывает `await orchestrator.run(websocket_in, websocket_out)`.
        5.  Если фабрика выбросила исключение (не удалось подключиться к TTS, и т.д.), отправляет клиенту сообщение об ошибке и закрывает соединение.

##### **3.3. Mediasoup (Media)**

* **Задача:** Исключительно прием и отправка RTP-потоков. Не содержит бизнес-логики.
* **Взаимодействие:**
    * Получает команды на создание `transports` и `producers/consumers` от `Orchestrator` через WebSocket (Control Plane).
    * При обнаружении голосовой активности пользователя во время `BOT_TURN`, отправляет по WebSocket сообщение `{"event": "barge_in_detected"}` в `Orchestrator`.

---

#### **4. Протокол Взаимодействия (Control Plane / WebSocket)**

WebSocket-соединение является "нервной системой" диалога.

##### **Сообщения от Клиента (Telephony Gateway) к Серверу:**

* **Первое сообщение (сразу после подключения):**
    * `{"event": "call_start", "payload": {"call_id": "...", "trace_id": "...", "initial_vars": {"contact_name": "..."}}}`
    * Запускает создание `Orchestrator`.
* **Сигнализация Mediasoup:**
    * `{"event": "mediasoup_request", "payload": {...}}`
    * Прозрачно проксируется в `Orchestrator` для настройки WebRTC.
* **Сообщение об обрыве связи:**
    * `{"event": "call_terminated"}`

##### **Сообщения от Сервера к Клиенту (Telephony Gateway):**

* **Подтверждение старта:**
    * `{"event": "call_accepted", "payload": {"status": "ok"}}`
* **Сигнализация Mediasoup:**
    * `{"event": "mediasoup_response", "payload": {...}}`
* **Команда на проигрывание аудио (НОВОЕ):**
    * `{"event": "play_audio", "payload": {"stream_id": "...", "rtp_port": 12345, "codec": "opus"}}`
    * `Orchestrator` не отправляет аудио напрямую. Он дает команду Медиа-серверу, а клиенту сообщает, на каком порту и в каком формате слушать этот поток от Mediasoup.
* **Команда на остановку аудио:**
    * `{"event": "stop_audio"}`
    * Отправляется при `barge-in`.

---

#### **5. Надежность и Отказоустойчивость (Fallbacks)**

Продумываем отказы заранее.

| Компонент / Событие | Проблема | Решение / Фолбэк |
| :--- | :--- | :--- |
| **Nginx** | Падение процесса | Мониторинг на уровне инфраструктуры (systemd, Kubernetes). Автоматический перезапуск. |
| **Gunicorn Worker** | Необработанное исключение в Python | Gunicorn автоматически перезапустит упавший `worker`. Кратковременные запросы получат ошибку 502, но система в целом продолжит работать. Звонок, который обслуживал `worker`, оборвется. |
| **Mediasoup** | Падение процесса | Критический сбой. `Orchestrator` обнаружит разрыв соединения при попытке отправить команду. Звонок должен быть немедленно завершен, ошибка логируется с уровнем CRITICAL. |
| **Redis (`Cache`)** | Недоступность | Каждый метод в `RedisCacheManager` обернут в `try/except`. При ошибке возвращается `None`. Система продоложает работать, но медленнее (деградирует). |
| **TTS / LLM / STT** | Внешний API недоступен | `Orchestrator` ловит исключение. **Фолбэк:** Проигрывает заранее записанный в `Cache` аудио-филлер (`static:technical_issue`), логирует ошибку и либо повторяет попытку, либо завершает звонок. |
| **`create_orchestrator`** | Не удалось подключиться к TTS при старте | Фабрика выбрасывает исключение. Uvicorn ловит его, отправляет клиенту `{"event": "call_failed", "reason": "TTS unavailable"}` и закрывает соединение. |

